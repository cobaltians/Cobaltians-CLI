#!/usr/bin/env node

var program = require('commander');
var config = require("./../src/config/index");
var log = require("./../src/helpers/log/index");
var Q = require('q');
var fs = require('fs-extra');
var path = require('path');
var readlineSync = require('readline-sync');

var known_templates = ['HelloWorld', 'Catalog', 'SideMenu'];
var appNameRegexp = /^[a-zA-Z0-9\-]+$/;

var commands = {
    platforms: []
};

program
    .parse(process.argv);

/*
 First we check that cli args are ok
 */

var dieWithAppNameError = function(){
    log.error("you must specify a valide app name.\n" +
      "App name must not contain spaces or special chars.\n" +
      "It should match regexp format "+appNameRegexp);
    process.exit(1);
};


var dieWithTemplateNameError = function(){
    log.error("you must specify a known template name.\n" +
      "Known template names are : " + known_templates.join(', '));
    process.exit(1);
};



if (!program.args[0]) {
    dieWithAppNameError();
} else {
    commands.appName = program.args[0];
    if (!commands.appName.match(appNameRegexp)) {
        dieWithAppNameError();
    }
}

if (!program.args[1]) {
    dieWithTemplateNameError();
} else {
    commands.templateName = program.args[1];
    if (known_templates.indexOf(commands.templateName) === -1) {
        dieWithTemplateNameError();
    }
}

if (program.args[2]) {
    commands.branch = program.args[2];
} else {
    commands.branch = "master";
}

var askPlatforms = function () {
    deferred = Q.defer();

    ios = readlineSync.question('Would you like to create an iOS app y/n  (default: y): ');
    android = readlineSync.question('Would you like to create an Android app y/n  (default: y): ');

    if (ios != 'n') commands.platforms.push('iOS');
    if (android != 'n') commands.platforms.push('Android');

    if (commands.platforms.length) {
        deferred.resolve();
    } else {
        deferred.reject('Cancelled');
    }
    return deferred.promise;
};

var createPath = function (newpath, eraseContent) {
    deferred = Q.defer();
    try {
        log.info('creating path '+ newpath);
        fs.mkdirSync(path.normalize(newpath));
        deferred.resolve();
    } catch (e) {
        //if (e.code != 'EEXIST')
        var question = 'A "'+newpath+'" folder already exists. ' + (eraseContent ?  'Erase content and continue' : 'Continue') + ' ? y/n  (default: y): ';
        if (readlineSync.question(question) !== 'n') {
            if (eraseContent){
                fs.emptyDirSync(newpath)
            }
            deferred.resolve();
        } else {
            deferred.reject("Canceled");
        }
    }
    return deferred.promise;
};

var gitCloneTemplate = function (platform) {
    Git = require('simple-git')();
    deferred = Q.defer();

    gitHubUrl = config.github_samples + 'Samples-' + commands.templateName + '-' + platform + '.git';
    localPath = path.normalize(commands.appName + '/' + platform + '/' + commands.appName);
    options = ['--recursive', '-b', commands.branch];

    return createPath(path.normalize(commands.appName + '/' + platform), true)
        .then(function(){
            log.info("Cloning " + gitHubUrl + " using branch " + commands.branch);

            return Git.clone(gitHubUrl, localPath, options);
        })
        .then(function(repository) {
            log.success("repository " + gitHubUrl + " cloned");
        }, function (reasonForFailure) {
            return deferred.reject("cannot clone the repository at " + gitHubUrl + " because " + reasonForFailure);
        });
};

var renameTemplate = function (platform) {
    var rename = require('./../src/helpers/rename/index');
    deferred = Q.defer();

    log.info("making the template for " + platform);

    if (platform == 'iOS') return rename.iosProject(path.normalize(commands.appName + '/' + platform + '/' + commands.appName), commands.templateName, commands.appName);
    if (platform == 'Android') return rename.androidProject(path.normalize(commands.appName + '/' + platform + '/' + commands.appName), commands.templateName, commands.appName);

    log.success(platform + ' template is done');

    deferred.resolve();
    return deferred.promise;
};

var cobaltiansFile = function () {
    deferred = Q.defer();

    log.info("Create cobaltians file");

    fs.writeJsonSync(path.normalize(commands.appName + '/cobaltians.json'), {
        name: commands.appName,
        cobaltVersion: '0.5.0', //TODO: check how to get last cobalt version,
        platforms: commands.platforms,
        plugins: []
    });

    deferred.resolve();
    return deferred.promise;
};

askPlatforms()
    .then(function () {
        //create myApp path.
        return createPath(program.args[0]);
    })
    .then(function () {
        return commands.platforms.reduce(function (previous, job) {
            return previous.then(function () {
                return gitCloneTemplate(job);
            });
        }, Q());
    })
    .then(function () {
        return commands.platforms.reduce(function (previous, job) {
            return previous.then(function () {
                return renameTemplate(job);
            });
        }, Q());
    })
    .then(cobaltiansFile)
    .then(function () {
        log.success("Finished");
    })
    .fail(function (err) {
        log.error(err);
        process.exit(1);
    });
