#!/usr/bin/env node

var program = require('commander');
var config = require("./../src/config/index");
var log = require("./../src/helpers/log/index");
var Q = require('q');
var fs = require('fs-extra');
var path = require('path');

var commands = {
    platforms: []
};

program
    .parse(process.argv);

/*
 First we check that cli args are ok
 */
if (!program.args[0]) {
    log.error("You must specify an app name");
    process.exit(1);
} else {
    commands.appName = program.args[0];
}

if (!program.args[1]) {
    log.error("you must specify a template name");
    process.exit(1);
} else {
    commands.templateName = program.args[1];
}

if (program.args[2]) {
    commands.branch = program.args[2];
}

var askPlatforms = function () {
    deferred = Q.defer();
    var readlineSync = require('readline-sync');

    ios = readlineSync.question('Would you like to create an iOS app y/n  (default: y): ');
    android = readlineSync.question('Would you like to create an Android app y/n  (default: y): ');

    if (ios != 'n') commands.platforms.push('iOS');
    if (android != 'n') commands.platforms.push('Android');

    deferred.resolve();
    return deferred.promise;
};

var createPath = function () {
    deferred = Q.defer();
    try {
        fs.mkdirSync(path.normalize(program.args[0]));
        deferred.resolve();
    } catch (e) {
        //if (e.code != 'EEXIST')
        deferred.reject("a folder already exists with the name " + program.args[0]);
    }
    return deferred.promise;
};

var getSubmodules = function (localPath){
    Ini = require('ini');

    log.success("getting submodules for " + localPath);
    modules = [];
    try{
        var config = Ini.parse(fs.readFileSync(path.normalize( localPath + '/.gitmodules'), 'utf-8'));
        log.success("Fetching submodules from .gitmodules");
        //if startswith submodule, push into modules
        for (var i in config) {
            if (i.indexOf('submodule') === 0){
                modules.push(config[i]);
            }
        }
    }catch(e){
        log.error('cant get submodules: '+ e)
    }
    return modules;
};

var initSubmodules=function(localPath, repository){
    deferred = Q.defer();
    Git = require('nodegit');

    var modules = getSubmodules(localPath);
    if (modules.length){
        i=0;
        return modules.reduce(function (previous, module) {
            return previous.then(function(){
                var modulePath = modules[i].path;
                i++;

                return Git.Submodule.lookup(repository, modulePath).then(function(submodule) {
                    log.success("got submodule '" + submodule.path() + "'");
                    try{
                        submodule.init(1);
                        log.success("submodule init worked");
                    }catch(e){
                        log.error("submodule init failed "+ e);
                    }
                    try{
                        submodule.update(1,new Git.CheckoutOptions);
                        log.success("submodule update worked");
                    }catch(e){
                        log.error("submodule update failed "+ e);
                    }
                    deferred.resolve();
                    return deferred.promise;

                },function(err){
                    log.error('cant get submodule : '+err)
                    deferred.resolve();
                    return deferred.promise;
                });
            });
        }, Q());
    }
    return deferred.promise;
};


var gitCloneTemplate = function (platform) {
    Git = require('nodegit');
    deferred = Q.defer();

    gitHubUrl = config.github_samples + 'Samples-' + commands.templateName + '-' + platform + '.git';
    localPath = path.normalize(commands.appName + '/' + platform + '/' + commands.appName);
    cloneOptions = {
        //for mac certificates bug. see nodegit guides.
        remoteCallbacks : {
            certificateCheck: function() { return 1; }
        }
    };
    log.info("Cloning " + gitHubUrl);

    if (commands.branch){
        log.info("Using branch " + commands.branch);
        cloneOptions.checkoutBranch=commands.branch;
    }

    return Git.Clone(gitHubUrl,localPath, cloneOptions)
        .then(function(repository) {
            log.success("repository " + gitHubUrl + " cloned");

            return initSubmodules(localPath, repository).then(function(repository) {
                log.success('submodule init ended');
                deferred.resolve();
                return deferred.promise;
            },function(){
                deferred.reject();
                return deferred.promise;
            });

        }, function (reasonForFailure) {
            return deferred.reject("cannot clone the repository at " + gitHubUrl + " because " + reasonForFailure);
        }
    );
};

var renameTemplate = function (platform) {
    var rename = require('./../src/helpers/rename/index');
    deferred = Q.defer();

    log.info("making the template for " + platform);

    if (platform == 'iOS') return rename.iosProject(path.normalize(commands.appName + '/' + platform + '/' + commands.appName), commands.templateName, commands.appName);
    if (platform == 'Android') return rename.androidProject(path.normalize(commands.appName + '/' + platform + '/' + commands.appName), commands.templateName, commands.appName);

    log.success(platform + ' template is done');

    deferred.resolve();
    return deferred.promise;
};

var cobaltiansFile = function () {
    deferred = Q.defer();

    log.info("Create cobaltians file");

    fs.writeJsonSync(path.normalize(commands.appName + '/cobaltians.json'), {
        name: commands.appName,
        cobaltVersion: '0.4.1', //TODO: check how to get last cobalt version,
        platforms: commands.platforms,
        plugins: []
    });

    deferred.resolve();
    return deferred.promise;
};

askPlatforms()
    .then(createPath)
    .then(function () {
        return commands.platforms.reduce(function (previous, job) {
            return previous.then(function () {
                return gitCloneTemplate(job);
            });
        }, Q());
    })
    .then(function () {
        return commands.platforms.reduce(function (previous, job) {
            return previous.then(function () {
                return renameTemplate(job);
            });
        }, Q());
    })
    .then(cobaltiansFile)
    .then(function () {
        log.success("Finished");
    })
    .fail(function (err) {
        log.error(err);
        process.exit(1);
    });